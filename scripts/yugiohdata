#!/usr/bin/env bun
// manage yugioh card assets

import * as os from "os"
import * as fs from "fs/promises"
import * as cp from "child_process"
import * as path from "path"
import * as https from "https"
import { cli } from "./cli"

const DIR = path.join(os.homedir(), "files/yugioh")
const IMG_DIR = path.join(DIR, "img")
const DATA_FILE = path.join(DIR, "data.json")
const API_URL = "https://db.ygoprodeck.com/api/v7/cardinfo.php"

function fetch(url) {
	return new Promise((resolve, reject) => {
		https.get(url, (res) => {
			const data = []
			res.on("data", (chunk) => data.push(chunk))
			res.on("end", () => resolve(Buffer.concat(data)))
		}).on("error", (err) => reject(err))
	})
}

async function updateDB() {
	console.log("fetching card info...")
	const content = await fetch(API_URL)
	await fs.mkdir(DIR, { recursive: true })
	await fs.writeFile(DATA_FILE, content.toString())
}

async function isFile(path) {
	try {
		const stat = await fs.stat(path)
		return stat.isFile()
	} catch {
		return false
	}
}

async function getCards() {
	if (!await isFile(DATA_FILE)) {
		await updateDB()
	}
	const data = JSON.parse(await fs.readFile(DATA_FILE, "utf8"))
	return data.data
}

function toIDMap(cards) {
	const map = {}
	for (const card of cards) {
		map[card.id] = card
	}
	return map
}

function toNameMap(cards) {
	const map = {}
	for (const card of cards) {
		map[card.name] = card
	}
	return map
}

async function exec(cmd, args, opts = {}) {
	return new Promise((resolve, reject) => {
		const proc = cp.spawn(cmd, args, {
			stdio: "inherit",
			...opts
		})
		proc.on("exit", resolve)
		proc.on("error", reject)
	})
}

var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var ARGUMENT_NAMES = /([^\s,]+)/g;
function getParamNames(func) {
	const fnStr = func.toString().replace(STRIP_COMMENTS, '')
	var result = fnStr.slice(fnStr.indexOf('(')+1, fnStr.indexOf(')')).match(ARGUMENT_NAMES)
	if(result === null)
	 result = []
	return result
}

const cmds = []

cmds.push({
	name: "update",
	desc: "Fetch newest card data from server and download card images",
	// TODO: remove unused images
	action: async () => {
		await updateDB()
		await fs.mkdir(IMG_DIR, { recursive: true })
		const cards = await getCards()
		const cardFiles = await fs.readdir(IMG_DIR)
		const existing = new Set(
			cardFiles.map((img) => path.basename(img, path.extname(img)))
		)
		for (const card of cards) {
			if (existing.has(card.id + "")) continue
			console.log(`${card.name} (${card.id})`)
			const img = await fetch(card.card_images[0].image_url)
			await fs.writeFile(path.join(IMG_DIR, `${card.id}.png`), img)
		}
	},
})

cmds.push({
	name: "search",
	desc: "Search a card",
	args: [
		{ name: "query", desc: "Search query" },
	],
	action: async ([query]) => {
		const cards = await getCards()
		const results = cards.filter((card) => {
			const target = card.name + card.desc
			return target.toLowerCase().includes(query.toLowerCase())
		})
		for (const card of results) {
			console.log(`${card.name} (${card.id})`)
		}
	},
})

cmds.push({
	name: "view",
	desc: "View a card image",
	args: [
		{ name: "id", desc: "Card ID" },
	],
	action: async ([id]) => {
		const cards = await getCards()
		const map = Number(id).toString() === id ? toIDMap(cards) : toNameMap(cards)
		const card = map[id]
		if (!card) return
		exec("open", [ path.join(IMG_DIR, `${card.id}.png`) ])
	},
})

try {
	await cli({
		desc: "Manage and query Yu-Gi-Oh! card data",
		cmds: cmds,
	})
} catch (e) {
	console.error(e.message)
}
